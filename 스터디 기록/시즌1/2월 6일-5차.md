# ✏️예지님

## 자바스크립트 메모리

- 메모리 할당 : 고수준 언어는 개발자가 신경 쓸 필요가 없는 부분이다.
- 메모리 사용 : 메모리를 쓰는 작업. 변수에서 읽거나 변수에 쓰는 작업. 함수에 인수를 넘겨줄 때도 일어남.
- 메모리 해제 : 프로그램에서 더이상 필요하지 않은 메모리 전체를 반환하여 재사용 가능하게 해주는 단계

## 메모리의 힙과 스택

- Code Area : 실제로 실행할 js 코드를 저장
- 스택 : 원시값, 참조 reference 할당. 미리 고정된 크기의 메모리를 사전에 할당. 컴파일 타임에 크기를 알 수 있음. 정적 메모리 할당
- 힙 : 객체 및 함수 할당. 런타임에 크기를 알 수 있음. 동적 메모리 할당

## 자바스크립트의 참조

- 변수 선언 및 할당을 하면 메모리의 어딘가에 위치한다. 이곳을 immutable, mutable 영역이라 부름.
- 모든 변수는 먼저 스택을 가르키고, 원시값이 아닌 경우 스택에서는 힙의 객체에 대한 참조가 포함된다.

## 가비지 컬렉션 (해제)

- 힙 내부엔 3개 이상의 가비지 컬렉션이 존재함. 각각 다른 내부 알고리즘을 통해 메모리를 최적화함.
- 어떤 변수나 함수가 더이상 필요하지 않다고 인식하면, 가비지컬렉션이 해당 변수 및 함수의 메모리를 해제함.

## 레퍼런스 카운팅

- 어느 한 메모리가 다른 메모리를 얼마나 많이 참조하는지 횟수를 세어 메모리에 접근 가능한지, 불가능한지 나누는 방식
- 순환 참조를 고려하지 않음
- 하나 이상의 객체가 서로 참조하지만, 더이상 코드를 통해 접근할 수 없을 때 문제 발생

## 마크 앤 스윕

- 주어진 객체에 대한 참조를 계산하는 대신, 루트 객체에서 도달할 수 있는지 감지
- 루트에서 도달할 수 없는 객체는 mark(쓰레기로 표시) 후 나중에 sweep(청소)함.

## 트레이드 오프

- 메모리 사용량
정확히 언제 메모리가 더이상 필요하지 않은 것인지 알 수 없음.
할당된 메모리를 수집할 시기와 수집 여부는 결국 가비지컬렉션에 달려 있다.
- 메모리 누수
전역 변수를 사용하다가 null 할당을 해주지 않으면 메모리 누수가 발생할 수 있다.
function 키워드로 정의한 함수도 마찬가지.
- 잊어버린 타이머와 콜백
타이머를 클리어해주지 않으면 백그라운드에서 계속 실행된다.
요즘은 문제가 되지 않지만, 더이상 사용하지 않는 이벤트리스너는 제거하는 것이 좋다.
- DOM 참조
    
    DOM 엘리먼트를 저장할 때 발생한다.
    DOM 엘리먼트가 가비지 컬렉터에 수집되려면 엘리먼트를 제거할 때 배열에서도 제거해야 한다.
    

---

# ✏️윤성님

# 동기와 비동기

## 콜백

“실행권을 위임한다”

다른 코드의 인수로서 넘겨주는 실행 가능한 코드

## 프로미스

특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 특성.

## 블로킹

호출된 함수가 자신의 할 일을 모두 마칠 때까지 제어권을 가지는 것.

## 논 블로킹

호출된 함수가 할 일을 마치지 않더라도, 바로 제어권을 내주어 호출된 함수가 다른 일을 진행할 수 있는 것

## 비동기 쉽게 이해하기

**동기**

1. 주문을 하기 위해 계산대에 줄을 선다.
2. 순서를 기다린다.
3. 순서가 되면, 음식을 주문한다.
4. 음식이 나올 때까지 줄에서 비키지 않고 계산대에서 대기한다.
5. 음식이 나오면서 줄에서 나와 자리에 앉아 식사를 한다.
6. 뒤에 줄 서 있는 고객들도 위 순서대로 음식을 주문한다.

 

1. 주문을 하기 위해 계산대에 줄을 선다.
2. 순서를 기다린다.
3. 순서가 되면, 음식을 주문한다.
4. 주문번호를 받고 자리에 앉아 음식이 나오기를 기다린다.
5. 뒤에 줄 서 있던 고객들도 순서대로 음식을 주문한다.
6. 주문한 음식이 완료되어 번호가 호출되면 음식을 가져간다.

## Promise

가독성이 떨어지는 패턴을 보완할 수 있다.

promise 생성자 함수에 인자로 들어갈 함수는 일반적으로 resolve, reject라는 2개의 매개변수를 갖는다.

promise 생성자 함수에 인자로 들어간 함수 내부에서 비동기 작업을 한다.

이때 비동기 작업이 성공하면 resolve를 실행하고, 실패하면 reject를 실행한다.

resolve : 실행 성공. → then 으로 추가 연산 진행

reject : 실패했다. → catch 으로 추가 연산 진행

프로미스는 **미래에 맞이할 성공 혹은 실패에 대한 결과값**을 나타낸다.

- Pending : 아직 결과가 정해지지 않은 상태(초기 상태)
- Fulfilled : 연산이 성공한 상태
- Rejected : 연산 실패한 상태

프로미스 인스턴스는 `.then` , `.catch` 등의 메소드를 사용할 수 있다.(체이닝 가능)

`resolve(결과)`의 결과가 `then`의 result로 가고, `reject(err)`의 err이 `catch`의 err로 간다.

에러 처리는 가급적 `catch()` 로 하는 것이 효율적이다.

---

# ✏️공지사항

가급적 최대 3명까지 발표합시다.

하루 발표 인원 3명이 넘어갈 때는 양보하거나, 꼭 발표하고 싶어요! 하는 분들은 말씀해주세요.

수기자는 발표하지 않아도 됩니다.

**2월 9일 스터디부터는 9시 30분에 진행합니다!**

조율하고자 하는 것이 있다면 편하게 이야기해주세요.
