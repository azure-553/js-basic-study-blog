### 디자인패턴 (예지님)
* 소프트웨어 디자인에서 일반적으로 발생하는 문제에 해결할 수 있는 반복 가능한 솔루션 

### 종류 
- Creational Design Pattern : 클래스 / 객체를 생성 하는 패턴 
- 클래스 : 인스턴스화 과정에서 상속을 어떻게 효율적으로 사용할 것인가? - 객체 : delegation을 어떻게 사용할 것인가? 
    - 예시 : 추상 팩토리, 빌더, 팩토리 메서드, 프로토타입, 싱글턴 패턴 등.. 
- Structural Design Pattern : 클래스, 객체가 새로운 기능을 얻기 위해 어떻게 구성되어야 할까? 
    - 예시 : 어댑터, 브릿지, 컴포지트, 데코레이터, 파사드, 프록시 패턴 등.. 
- Behavioral Design Pattern : 클래스 간 통신에 관한 패턴 
    - 예시 : 커맨드, 이터레이터, 중재자, 옵저버, 템플릿 메서드, 방문자 패턴 등.. 
    
### 질문 
1. 아키텍쳐와 디자인 패턴의 차이점? (윤성님) 
    - 아키텍쳐가 더 큰 개념

## 리액트에서의 이벤트와 상태 (윤성님) 
### Event Handler 
이벤트 핸들러에 전달되는 함수는 호출이 아니라 전달되어야 한다. 
이벤트 구현 사항을 컴포넌트 내부에서 작성 / 또는 props로 전달 가능 
- 내부에서 작성할 경우 핸들러 이름은 handle로 시작 
- 외부에서 전달 받을 경우 핸들러 이름은 on으로 시작 

### State 상태 : 컴포넌트의 메모리 리액트는 상태 업데이트를 일괄 처리 
- 모든 이벤트 핸들러가 실행되고 
- set 함수 호출 후에 화면 업데이트 하나의 동작에서 여러 번 상태를 set 하려면 함수를 전달해라 

### State as snapshot 리액트는 스냅샷을 가지고 있기 때문에 상태 업데이트가 원하는 대로 되지 않을 때가 있다 (초보가 실수하기 쉽다) 
- onClick 이후 setNumber() 3번 호출 -> 상태가 3 증가? - 그렇지 않다. 초기 상태인 0이 스냅샷 -> setter에 의해 늘어난 숫자는 1 밖에 안된다 
- 때문에 상태를 여러 번 업데이트 하는 것은 바람직하지 않다 
- 리액트가 상태를 업데이트하는 시점에 스냅샷을 찍기 때문 
- 그리고 렌더링하는 동안에는 상태를 변화시키지 않는다. 이벤트 핸들러 내부에서 setTimeout을 사용해도 변화의 순간만을 기억해서 반환한다. 해결하기 위해서는? 배치 업데이트라는 것을 활용 

### 질문 setNumber 3번 호출 예시가 자바와 다른 점? 
- 렌더링 되는 도중에 상태가 변하지 않는다. 
- 상태가 변했기 때문에 렌더링되기 때문 리액트가 스냅샷을 사용하는 이유 
- 리액트는 옵저버 패턴을 사용. 
- 이벤트를 실행시킬 시점에 스냅샷을 찍어 두고 
- 그걸 기반으로 렌더링 수행 
- 때문에 스냅샷을 사용하지 않는다면 상태가 계속 변하는 것을 계속해서 렌더링 수행해야 하는데, 이게 계속되면 화면에 아무것도 나타나지 않을 수 있음 
컴포넌트 상태가 변화하면 리액트가 감지하고 렌더 큐에 등록하는 과정 : 트리거 렌더 큐에 대기하는 컴포넌트가 가상 돔 상에서 새롭게 그려지는 과정 : 렌더 실제 돔에 대기하는 컴포넌트 위치를 알려 새롭게 리페인트 하기 위한 과정에서 발생하는 것: 커밋 왜 리액트는 이런 과정을 거칠까? : 리렌더링에 소모되는 리소스를 절약하기 위해서. '변화가 일어난 위치만' 다시 그리면 효율적이다!