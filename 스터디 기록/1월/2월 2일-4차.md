# 1. ****redjen****님

### 주제 : this

- 전형적인 문맥에서 : 엄격 모드에 상관 없이 전역 객체를 참조

보통 함수 호출을 할 때, this는 암묵적으로 함수의 prefix에 붙어서 전달되는 파라미터처럼 전달된다. 명시적으로 this에 대한 값을 설정하기 위해서는 Function.prototype.call(), Function.prototype.apply(), Reflect.apply()를 사용할 수 있다.

보통 함수 호출을 할 때

프로토 타입 스킵

콜백

그 객체를 가리킴

익명함수 

this값이 전역 객체를 가리킴

로그 디스 예제

```
function C() {
    this.a = 37;
}

let o = new C();
console.log(o.a); //37

function C2() {
    this.a = 37;
    return { a : 38 };
}

o = new C2();
console.log(o.a); // 38
```

어떤 함수를 상속할 경우 

객체를 상속하게 되는 스코프를 엄밀히 검토

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2ba7770-27e6-4ba4-b69a-54b76a3b3c44/Untitled.png)

어려움

적 메서드들은 클래스 자체의 속성들이다. 그렇기 때문에 정적 메서드들은 클래스에 의해 보통 접근되고, `this`
 값은 클래스의 값을 가르킨다. static 초기화 블록들은 현재 클래스에서 설정된 `this`
 값과 함께 evaluate 된다.

기반이 되는 클래스 생성자와는 달리, 파생 클래스 생성자에서는 처음에 `this`
 값에 대한 바인딩이 존재하지 않는다. `super()`
를 호출하게 되면 그제서야 생성자 내에서 `this`
 바인딩을 생성되고, 기본적으로는 다름 코드 line을 evaluate한다.

---

전역 컨테스트 에서 this ⇒

# 2. 세웅님
### 주제 : 프로토타입

자바스크립트 - 프로토아입 기반 언어

클래스 기반언어 :: 상속이 따로 있음.

상속을 유사하게 사용

자바스크립트는 프로토타입 기반 언어다. 클래스 기반 언어에서는 상속을 사용하지만, 프로토타입 기반 언저에서는 어떤 객체를 프로토타입(원형)으로 삼고 이클 복제 함으로써 상속과 비슷한 효과를 얻습니다

프로토타입 이해

→ 생성자 함수 알아야 함.

자바스크립트와 자바의 차이

함수로 클래스 같은 역할

생성자 함수로 생성자 인스턴스 생성 가능

### 프로토 타입

construct가 new 연산자와 함께 호출 → 새로운 인스턴스 생성

먼저 프로토 프로퍼티 자동 부여
construct의 prototype이라는 프로퍼티 참조

이름이 다른 것 → 조금 씩 차이가 있음

생성자 함수를 선언할 때 사용되는 이름이 표시가 됨

뿌리가 갖고있는 프로토 타입도 표시됨

this 안에 name 이 없어서 호출하지 못함

this안에 무언가 있어야함

근데 뭔가 있기 떄문에 반환 값이 없다면, undefined 아니고 타입에러가 나야하는게 맞다.

메서드 오버라이드

→ 인스턴스가 동일한 이름의 프로퍼티


프로토타입 자체는 어렵지 X

### 질문 & 토론
근데, 프로토타입으로 상속을 받으면 public,private같이 사용하는 것이 없나?

클래스 문법 새로 지원

최상위 부모를 건드리는 것과 같음. 프로토타입을 많이 쓰지 않는 추세. 모든 객체들이 상속 받고 있는 

클래스 메서드 지원 → 자바에서 자바스크립트 똑같은 역할 다르게 동작

1. 두 코드의 결과는 동일하며, 동작 방식도 거의 차이가 없다. 즉 ES6 클래스 문법은 단지 생성자-프로토타입 패턴을 숨기기 위한 Syntactic Sugar에 불과하다. JS는 여전히 프로토타입 기반 언어이다.

윤성님 : 중요, 실무 → 함수형 요즘은 접근하기 어려움.
너무 매몰되지 말것
클래스는 생각보다 안쓰임
자바스크립트의 동작 원리를 깨우치기 위해 
함수랑 다를 바 없다고 봄
→ 생성자 함수로 가져가면, 그대로. 

자바스크립트에서 클래스 구현체를 구현하는 것은 자바와 좀 다르다.
오히려 클래스를 적극적으로 써서 접근제어자 지정해서 변경x

현업에서 프론트엔드 변화는 빠름
형상 하나를 정해놓고 트랜드를 따라가는 것이 좋음
현업이냐 아니야에 따라 중요도가 다름

→ 클래스 오브젝트

공식 문서에서도 함수형 권장

프론트에서 백엔드를 할거면 노드!

결국 클래스가 있어도 억지로 사용

노드 대 파이썬 

파이썬 → 자바에 가깝
러닝커브 적음 

언어 자체보다 어떤 도메인을 쓰느냐가 중요함
수학적인게 아니면 노드를 사용

파이썬보다 노드가 더 빠른..
파이썬 → 지원이 많음

그냥 할 거면 파이썬이 더 편하다. 데이터 다루기 쉬움
자료,라이브러리 잘 정리 되어있음
러닝커브가 높지도 않은 것 같음

노드는 프론트가 풀 역할하기 위해.
자바는 이것저것 못하게함.. 규제를 걸어놓음

왜? 자스는 편하게, 자바는 객체지향을 위한 언어

백에서 클래스 네스트는 좀 불편했음
자바는 자유 억압하는 느낌..

자바 → 데이터를 위한 언어

사실 현업 → 프론트에서 
프론트 → 접근을 할 수 있는 
백엔드 → 보안 적으로 중요한 데이터를 다루기 위해

프레임 워크 의존적이면 안 좋다.

내가 하고 있는 영역에 대한 판단, 기능 중점 
→ 개인 개발할 때 이해가 편하다고 생각함.